{"version":3,"file":"Swup.cjs","sources":["../src/helpers/classify.ts","../src/helpers/getCurrentUrl.ts","../src/helpers/createHistoryRecord.ts","../src/helpers/updateHistoryRecord.ts","../src/helpers/delegateEvent.ts","../src/helpers/Location.ts","../src/modules/fetchPage.ts","../src/modules/Cache.ts","../src/utils/index.ts","../src/modules/Classes.ts","../src/modules/Visit.ts","../src/modules/Hooks.ts","../src/modules/getAnchorElement.ts","../src/modules/awaitAnimations.ts","../src/modules/navigate.ts","../src/modules/animatePageOut.ts","../src/modules/replaceContent.ts","../src/modules/scrollToContent.ts","../src/modules/animatePageIn.ts","../src/modules/renderPage.ts","../src/modules/plugins.ts","../src/modules/resolveUrl.ts","../src/Swup.ts","../src/helpers/matchPath.ts"],"sourcesContent":["/** Turn a string into a slug by lowercasing and replacing whitespace. */\nexport const classify = (text: string, fallback?: string): string => {\n\tconst output = String(text)\n\t\t.toLowerCase()\n\t\t// .normalize('NFD') // split an accented letter in the base letter and the acent\n\t\t// .replace(/[\\u0300-\\u036f]/g, '') // remove all previously split accents\n\t\t.replace(/[\\s/_.]+/g, '-') // replace spaces and _./ with '-'\n\t\t.replace(/[^\\w-]+/g, '') // remove all non-word chars\n\t\t.replace(/--+/g, '-') // replace repeating '-' with single '-'\n\t\t.replace(/^-+|-+$/g, ''); // trim '-' from edges\n\treturn output || fallback || '';\n};\n","/** Get the current page URL: path name + query params. Optionally including hash. */\nexport const getCurrentUrl = ({ hash }: { hash?: boolean } = {}): string => {\n\treturn location.pathname + location.search + (hash ? location.hash : '');\n};\n","import { getCurrentUrl } from './getCurrentUrl.js';\n\nexport interface HistoryState {\n\turl: string;\n\tsource: 'swup';\n\trandom: number;\n\tindex?: number;\n\t[key: string]: unknown;\n}\n\n/** Create a new history record with a custom swup identifier. */\nexport const createHistoryRecord = (\n\turl: string,\n\tcustomData: Record<string, unknown> = {}\n): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst data: HistoryState = {\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...customData\n\t};\n\thistory.pushState(data, '', url);\n};\n","import type { HistoryState } from './createHistoryRecord.js';\nimport { getCurrentUrl } from './getCurrentUrl.js';\n\n/** Update the current history record with a custom swup identifier. */\nexport const updateHistoryRecord = (\n\turl: string | null = null,\n\tcustomData: Record<string, unknown> = {}\n): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst state = (history.state as HistoryState) || {};\n\tconst data: HistoryState = {\n\t\t...state,\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...customData\n\t};\n\thistory.replaceState(data, '', url);\n};\n","import delegate, {\n\ttype DelegateEventHandler,\n\ttype DelegateOptions,\n\ttype EventType\n} from 'delegate-it';\nimport type { ParseSelector } from 'typed-query-selector/parser.js';\n\nexport type DelegateEventUnsubscribe = {\n\tdestroy: () => void;\n};\n\n/** Register a delegated event listener. */\nexport const delegateEvent = <\n\tSelector extends string,\n\tTElement extends Element = ParseSelector<Selector, HTMLElement>,\n\tTEvent extends EventType = EventType\n>(\n\tselector: Selector,\n\ttype: TEvent,\n\tcallback: DelegateEventHandler<GlobalEventHandlersEventMap[TEvent], TElement>,\n\toptions?: DelegateOptions\n): DelegateEventUnsubscribe => {\n\tconst controller = new AbortController();\n\toptions = { ...options, signal: controller.signal };\n\tdelegate<Selector, TElement, TEvent>(selector, type, callback, options);\n\treturn { destroy: () => controller.abort() };\n};\n","/**\n * A helper for creating a Location from either an element\n * or a URL object/string\n *\n */\nexport class Location extends URL {\n\tconstructor(url: URL | string, base: string = document.baseURI) {\n\t\tsuper(url.toString(), base);\n\t}\n\n\t/**\n\t * The full local path including query params.\n\t */\n\tget url(): string {\n\t\treturn this.pathname + this.search;\n\t}\n\n\t/**\n\t * Instantiate a Location from an element's href attribute\n\t * @param el\n\t * @returns new Location instance\n\t */\n\tstatic fromElement(el: Element): Location {\n\t\tconst href = el.getAttribute('href') || el.getAttribute('xlink:href') || '';\n\t\treturn new Location(href);\n\t}\n\n\t/**\n\t * Instantiate a Location from a URL object or string\n\t * @param url\n\t * @returns new Location instance\n\t */\n\tstatic fromUrl(url: URL | string): Location {\n\t\treturn new Location(url);\n\t}\n}\n","import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\n\n/** A page object as used by swup and its cache. */\nexport interface PageData {\n\t/** The URL of the page */\n\turl: string;\n\t/** The complete HTML response received from the server */\n\thtml: string;\n}\n\n/** Define how a page is fetched. */\nexport interface FetchOptions extends Omit<RequestInit, 'cache'> {\n\t/** The request method. */\n\tmethod?: 'GET' | 'POST';\n\t/** The body of the request: raw string, form data object or URL params. */\n\tbody?: string | FormData | URLSearchParams;\n\t/** The request timeout in milliseconds. */\n\ttimeout?: number;\n}\n\nexport class FetchError extends Error {\n\turl: string;\n\tstatus?: number;\n\taborted: boolean;\n\ttimedOut: boolean;\n\tconstructor(\n\t\tmessage: string,\n\t\tdetails: { url: string; status?: number; aborted?: boolean; timedOut?: boolean }\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'FetchError';\n\t\tthis.url = details.url;\n\t\tthis.status = details.status;\n\t\tthis.aborted = details.aborted || false;\n\t\tthis.timedOut = details.timedOut || false;\n\t}\n}\n\n/**\n * Fetch a page from the server, return it and cache it.\n */\nexport async function fetchPage(\n\tthis: Swup,\n\turl: URL | string,\n\toptions: FetchOptions = {}\n): Promise<PageData> {\n\turl = Location.fromUrl(url).url;\n\n\tconst headers = { ...this.options.requestHeaders, ...options.headers };\n\tconst timeout = options.timeout ?? this.options.timeout;\n\tconst controller = new AbortController();\n\tconst { signal } = controller;\n\toptions = { ...options, headers, signal };\n\n\tlet timedOut = false;\n\tlet timeoutId: ReturnType<typeof setTimeout> | null = null;\n\tif (timeout && timeout > 0) {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimedOut = true;\n\t\t\tcontroller.abort('timeout');\n\t\t}, timeout);\n\t}\n\n\t// Allow hooking before this and returning a custom response-like object (e.g. custom fetch implementation)\n\tlet response: Response;\n\ttry {\n\t\tresponse = await this.hooks.call(\n\t\t\t'fetch:request',\n\t\t\t{ url, options },\n\t\t\t(visit, { url, options }) => fetch(url, options)\n\t\t);\n\t\tif (timeoutId) {\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t} catch (error) {\n\t\tif (timedOut) {\n\t\t\tthis.hooks.call('fetch:timeout', { url });\n\t\t\tthrow new FetchError(`Request timed out: ${url}`, { url, timedOut });\n\t\t}\n\t\tif ((error as Error)?.name === 'AbortError' || signal.aborted) {\n\t\t\tthrow new FetchError(`Request aborted: ${url}`, {\n\t\t\t\turl: url,\n\t\t\t\taborted: true\n\t\t\t});\n\t\t}\n\t\tthrow error;\n\t}\n\n\tconst { status, url: responseUrl } = response;\n\tconst html = await response.text();\n\n\tif (status === 500) {\n\t\tthis.hooks.call('fetch:error', { status, response, url: responseUrl });\n\t\tthrow new FetchError(`Server error: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\tif (!html) {\n\t\tthrow new FetchError(`Empty response: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\t// Resolve real url after potential redirect\n\tconst { url: finalUrl } = Location.fromUrl(responseUrl);\n\tconst page = { url: finalUrl, html };\n\n\t// Write to cache for safe methods and non-redirects\n\tif (\n\t\tthis.visit.cache.write &&\n\t\t(!options.method || options.method === 'GET') &&\n\t\turl === finalUrl\n\t) {\n\t\tthis.cache.set(page.url, page);\n\t}\n\n\treturn page;\n}\n","import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\nimport { type PageData } from './fetchPage.js';\n\nexport interface CacheData extends PageData {}\n\n/**\n * In-memory page cache.\n */\nexport class Cache {\n\t/** Swup instance this cache belongs to */\n\tprotected swup: Swup;\n\n\t/** Cached pages, indexed by URL */\n\tprotected pages: Map<string, CacheData> = new Map();\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\t/** Number of cached pages in memory. */\n\tget size(): number {\n\t\treturn this.pages.size;\n\t}\n\n\t/** All cached pages. */\n\tget all() {\n\t\tconst copy = new Map();\n\t\tthis.pages.forEach((page, key) => {\n\t\t\tcopy.set(key, { ...page });\n\t\t});\n\t\treturn copy;\n\t}\n\n\t/** Check if the given URL has been cached. */\n\thas(url: string): boolean {\n\t\treturn this.pages.has(this.resolve(url));\n\t}\n\n\t/** Return a shallow copy of the cached page object if available. */\n\tget(url: string): CacheData | undefined {\n\t\tconst result = this.pages.get(this.resolve(url));\n\t\tif (!result) return result;\n\t\treturn { ...result };\n\t}\n\n\t/** Create a cache record for the specified URL. */\n\tset(url: string, page: CacheData) {\n\t\turl = this.resolve(url);\n\t\tpage = { ...page, url };\n\t\tthis.pages.set(url, page);\n\t\tthis.swup.hooks.callSync('cache:set', { page });\n\t}\n\n\t/** Update a cache record, overwriting or adding custom data. */\n\tupdate(url: string, payload: object) {\n\t\turl = this.resolve(url);\n\t\tconst page = { ...this.get(url), ...payload, url } as CacheData;\n\t\tthis.pages.set(url, page);\n\t}\n\n\t/** Delete a cache record. */\n\tdelete(url: string): void {\n\t\tthis.pages.delete(this.resolve(url));\n\t}\n\n\t/** Empty the cache. */\n\tclear(): void {\n\t\tthis.pages.clear();\n\t\tthis.swup.hooks.callSync('cache:clear', undefined);\n\t}\n\n\t/** Remove all cache entries that return true for a given predicate function.  */\n\tprune(predicate: (url: string, page: CacheData) => boolean): void {\n\t\tthis.pages.forEach((page, url) => {\n\t\t\tif (predicate(url, page)) {\n\t\t\t\tthis.delete(url);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** Resolve URLs by making them local and letting swup resolve them. */\n\tprotected resolve(urlToResolve: string): string {\n\t\tconst { url } = Location.fromUrl(urlToResolve);\n\t\treturn this.swup.resolveUrl(url);\n\t}\n}\n","/** Find an element by selector. */\nexport const query = (selector: string, context: Document | Element = document) => {\n\treturn context.querySelector<HTMLElement>(selector);\n};\n\n/** Find a set of elements by selector. */\nexport const queryAll = (\n\tselector: string,\n\tcontext: Document | Element = document\n): HTMLElement[] => {\n\treturn Array.from(context.querySelectorAll(selector));\n};\n\n/** Return a Promise that resolves after the next event loop. */\nexport const nextTick = (): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\trequestAnimationFrame(() => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n};\n\n/** Check if an object is a Promise or a Thenable */\nexport function isPromise<T>(obj: unknown): obj is PromiseLike<T> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === 'object' || typeof obj === 'function') &&\n\t\ttypeof (obj as Record<string, unknown>).then === 'function'\n\t);\n}\n\n/** Call a function as a Promise. Resolves with the returned Promsise or immediately. */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nexport function runAsPromise(func: Function, args: unknown[] = []): Promise<unknown> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst result: unknown = func(...args);\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n}\n\n/**\n * Force a layout reflow, e.g. after adding classnames\n * @returns The offset height, just here so it doesn't get optimized away by the JS engine\n * @see https://stackoverflow.com/a/21665117/3759615\n */\nexport function forceReflow(element?: HTMLElement) {\n\telement = element || document.body;\n\treturn element?.offsetHeight;\n}\n\n/** Escape a string with special chars to not break CSS selectors. */\nexport const escapeCssIdentifier = (ident: string) => {\n\t// @ts-ignore this is for support check, so it's correct that TS complains\n\tif (window.CSS && window.CSS.escape) {\n\t\treturn CSS.escape(ident);\n\t}\n\treturn ident;\n};\n\n/** Fix for Chrome below v61 formatting CSS floats with comma in some locales. */\nexport const toMs = (s: string) => {\n\treturn Number(s.slice(0, -1).replace(',', '.')) * 1000;\n};\n","import type Swup from '../Swup.js';\nimport { queryAll } from '../utils.js';\n\nexport class Classes {\n\tprotected swup: Swup;\n\tprotected swupClasses = ['to-', 'is-changing', 'is-rendering', 'is-popstate', 'is-animating'];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\tprotected get selectors(): string[] {\n\t\tconst { scope } = this.swup.visit.animation;\n\t\tif (scope === 'containers') return this.swup.visit.containers;\n\t\tif (scope === 'html') return ['html'];\n\t\tif (Array.isArray(scope)) return scope;\n\t\treturn [];\n\t}\n\n\tprotected get selector(): string {\n\t\treturn this.selectors.join(',');\n\t}\n\n\tprotected get targets(): HTMLElement[] {\n\t\tif (!this.selector.trim()) return [];\n\t\treturn queryAll(this.selector);\n\t}\n\n\tadd(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.add(...classes));\n\t}\n\n\tremove(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.remove(...classes));\n\t}\n\n\tclear(): void {\n\t\tthis.targets.forEach((target) => {\n\t\t\tconst remove = target.className.split(' ').filter((c) => this.isSwupClass(c));\n\t\t\ttarget.classList.remove(...remove);\n\t\t});\n\t}\n\n\tprotected isSwupClass(className: string): boolean {\n\t\treturn this.swupClasses.some((c) => className.startsWith(c));\n\t}\n}\n","import type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\nimport type { HistoryAction, HistoryDirection } from './navigate.js';\n\n/** An object holding details about the current visit. */\nexport interface Visit {\n\t/** A unique ID to identify this visit */\n\tid: number;\n\t/** The previous page, about to leave */\n\tfrom: VisitFrom;\n\t/** The next page, about to enter */\n\tto: VisitTo;\n\t/** The content containers, about to be replaced */\n\tcontainers: Options['containers'];\n\t/** Information about animated page transitions */\n\tanimation: VisitAnimation;\n\t/** What triggered this visit */\n\ttrigger: VisitTrigger;\n\t/** Cache behavior for this visit */\n\tcache: VisitCache;\n\t/** Browser history behavior on this visit */\n\thistory: VisitHistory;\n\t/** Scroll behavior on this visit */\n\tscroll: VisitScroll;\n}\n\nexport interface VisitFrom {\n\t/** The URL of the previous page */\n\turl: string;\n}\n\nexport interface VisitTo {\n\t/** The URL of the next page */\n\turl: string;\n\t/** The hash of the next page */\n\thash?: string;\n\t/** The HTML content of the next page */\n\thtml?: string;\n}\n\nexport interface VisitAnimation {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate: boolean;\n\t/** Whether to wait for the next page to load before starting the animation. Default: `false` */\n\twait: boolean;\n\t/** Name of a custom animation to run. */\n\tname?: string;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tscope: 'html' | 'containers' | string[];\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tselector: Options['animationSelector'];\n}\n\nexport interface VisitScroll {\n\t/** Whether to reset the scroll position after the visit. Default: `true` */\n\treset: boolean;\n\t/** Anchor element to scroll to on the next page. */\n\ttarget?: string | false;\n}\n\nexport interface VisitTrigger {\n\t/** DOM element that triggered this visit. */\n\tel?: Element;\n\t/** DOM event that triggered this visit. */\n\tevent?: Event;\n}\n\nexport interface VisitCache {\n\t/** Whether this visit will try to load the requested page from cache. */\n\tread: boolean;\n\t/** Whether this visit will save the loaded page in cache. */\n\twrite: boolean;\n}\n\nexport interface VisitHistory {\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\taction: HistoryAction;\n\t/** Whether this visit was triggered by a browser history navigation. */\n\tpopstate: boolean;\n\t/** The direction of travel in case of a browser history navigation: backward or forward. */\n\tdirection: HistoryDirection | undefined;\n}\n\nexport interface VisitInitOptions {\n\tto: string;\n\tfrom?: string;\n\thash?: string;\n\tel?: Element;\n\tevent?: Event;\n}\n\n/** Create a new visit object. */\nexport function createVisit(\n\tthis: Swup,\n\t{ to, from = this.currentPageUrl, hash, el, event }: VisitInitOptions\n): Visit {\n\treturn {\n\t\tid: Math.random(),\n\t\tfrom: { url: from },\n\t\tto: { url: to, hash },\n\t\tcontainers: this.options.containers,\n\t\tanimation: {\n\t\t\tanimate: true,\n\t\t\twait: false,\n\t\t\tname: undefined,\n\t\t\tscope: this.options.animationScope,\n\t\t\tselector: this.options.animationSelector\n\t\t},\n\t\ttrigger: {\n\t\t\tel,\n\t\t\tevent\n\t\t},\n\t\tcache: {\n\t\t\tread: this.options.cache,\n\t\t\twrite: this.options.cache\n\t\t},\n\t\thistory: {\n\t\t\taction: 'push',\n\t\t\tpopstate: false,\n\t\t\tdirection: undefined\n\t\t},\n\t\tscroll: {\n\t\t\treset: true,\n\t\t\ttarget: undefined\n\t\t}\n\t};\n}\n","import type { DelegateEvent } from 'delegate-it';\n\nimport type Swup from '../Swup.js';\nimport { isPromise, runAsPromise } from '../utils.js';\nimport type { Visit } from './Visit.js';\nimport type { FetchOptions, PageData } from './fetchPage.js';\n\nexport interface HookDefinitions {\n\t'animation:out:start': undefined;\n\t'animation:out:await': { skip: boolean };\n\t'animation:out:end': undefined;\n\t'animation:in:start': undefined;\n\t'animation:in:await': { skip: boolean };\n\t'animation:in:end': undefined;\n\t'animation:skip': undefined;\n\t'cache:clear': undefined;\n\t'cache:set': { page: PageData };\n\t'content:replace': { page: PageData };\n\t'content:scroll': undefined;\n\t'enable': undefined;\n\t'disable': undefined;\n\t'fetch:request': { url: string; options: FetchOptions };\n\t'fetch:error': { url: string; status: number; response: Response };\n\t'fetch:timeout': { url: string };\n\t'history:popstate': { event: PopStateEvent };\n\t'link:click': { el: HTMLAnchorElement; event: DelegateEvent<MouseEvent> };\n\t'link:self': undefined;\n\t'link:anchor': { hash: string };\n\t'link:newtab': { href: string };\n\t'page:load': { page?: PageData; cache?: boolean; options: FetchOptions };\n\t'page:view': { url: string; title: string };\n\t'scroll:top': { options: ScrollIntoViewOptions };\n\t'scroll:anchor': { hash: string; options: ScrollIntoViewOptions };\n\t'visit:start': undefined;\n\t'visit:transition': undefined;\n\t'visit:end': undefined;\n}\n\nexport interface HookReturnValues {\n\t'content:scroll': Promise<boolean>;\n\t'fetch:request': Promise<Response>;\n\t'page:load': Promise<PageData>;\n\t'scroll:top': boolean;\n\t'scroll:anchor': boolean;\n\t'visit:transition': Promise<boolean>;\n}\n\nexport type HookArguments<T extends HookName> = HookDefinitions[T];\n\nexport type HookName = keyof HookDefinitions;\n\n/** A generic hook handler. */\nexport type HookHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>\n) => Promise<unknown> | unknown;\n\n/** A default hook handler with an expected return type. */\nexport type HookDefaultHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>,\n\t/** Default handler to be executed. Available if replacing an internal hook handler. */\n\tdefaultHandler?: HookDefaultHandler<T>\n) => T extends keyof HookReturnValues ? HookReturnValues[T] : Promise<unknown> | unknown;\n\nexport type Handlers = {\n\t[K in HookName]: HookHandler<K>[];\n};\n\n/** Unregister a previously registered hook handler. */\nexport type HookUnregister = () => void;\n\n/** Define when and how a hook handler is executed. */\nexport type HookOptions = {\n\t/** Execute the hook once, then remove the handler */\n\tonce?: boolean;\n\t/** Execute the hook before the internal default handler */\n\tbefore?: boolean;\n\t/** Set a priority for when to execute this hook. Lower numbers execute first. Default: `0` */\n\tpriority?: number;\n\t/** Replace the internal default handler with this hook handler */\n\treplace?: boolean;\n};\n\nexport type HookRegistration<\n\tT extends HookName,\n\tH extends HookHandler<T> | HookDefaultHandler<T> = HookHandler<T>\n> = {\n\tid: number;\n\thook: T;\n\thandler: H;\n\tdefaultHandler?: HookDefaultHandler<T>;\n} & HookOptions;\n\ntype HookLedger<T extends HookName> = Map<HookHandler<T>, HookRegistration<T>>;\n\ninterface HookRegistry extends Map<HookName, HookLedger<HookName>> {\n\tget<K extends HookName>(key: K): HookLedger<K> | undefined;\n\tset<K extends HookName>(key: K, value: HookLedger<K>): this;\n}\n\n/**\n * Hook registry.\n *\n * Create, trigger and handle hooks.\n *\n */\nexport class Hooks {\n\t/** Swup instance this registry belongs to */\n\tprotected swup: Swup;\n\n\t/** Map of all registered hook handlers. */\n\tprotected registry: HookRegistry = new Map();\n\n\t// Can we deduplicate this somehow? Or make it error when not in sync with HookDefinitions?\n\t// https://stackoverflow.com/questions/53387838/how-to-ensure-an-arrays-values-the-keys-of-a-typescript-interface/53395649\n\tprotected readonly hooks: HookName[] = [\n\t\t'animation:out:start',\n\t\t'animation:out:await',\n\t\t'animation:out:end',\n\t\t'animation:in:start',\n\t\t'animation:in:await',\n\t\t'animation:in:end',\n\t\t'animation:skip',\n\t\t'cache:clear',\n\t\t'cache:set',\n\t\t'content:replace',\n\t\t'content:scroll',\n\t\t'enable',\n\t\t'disable',\n\t\t'fetch:request',\n\t\t'fetch:error',\n\t\t'fetch:timeout',\n\t\t'history:popstate',\n\t\t'link:click',\n\t\t'link:self',\n\t\t'link:anchor',\n\t\t'link:newtab',\n\t\t'page:load',\n\t\t'page:view',\n\t\t'scroll:top',\n\t\t'scroll:anchor',\n\t\t'visit:start',\n\t\t'visit:transition',\n\t\t'visit:end'\n\t];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Create ledgers for all core hooks.\n\t */\n\tprotected init() {\n\t\tthis.hooks.forEach((hook) => this.create(hook));\n\t}\n\n\t/**\n\t * Create a new hook type.\n\t */\n\tcreate(hook: string) {\n\t\tif (!this.registry.has(hook as HookName)) {\n\t\t\tthis.registry.set(hook as HookName, new Map());\n\t\t}\n\t}\n\n\t/**\n\t * Check if a hook type exists.\n\t */\n\texists(hook: HookName): boolean {\n\t\treturn this.registry.has(hook);\n\t}\n\n\t/**\n\t * Get the ledger with all registrations for a hook.\n\t */\n\tprotected get<T extends HookName>(hook: T): HookLedger<T> | undefined {\n\t\tconst ledger = this.registry.get(hook);\n\t\tif (ledger) {\n\t\t\treturn ledger;\n\t\t}\n\t\tconsole.error(`Unknown hook '${hook}'`);\n\t}\n\n\t/**\n\t * Remove all handlers of all hooks.\n\t */\n\tclear() {\n\t\tthis.registry.forEach((ledger) => ledger.clear());\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Object to specify how and when the handler is executed\n\t *                Available options:\n\t *                - `once`: Only execute the handler once\n\t *                - `before`: Execute the handler before the default handler\n\t *                - `priority`: Specify the order in which the handlers are executed\n\t *                - `replace`: Replace the default handler with this handler\n\t * @returns A function to unregister the handler\n\t */\n\n\t// Overload: replacing default handler\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookDefaultHandler<T>, options: O & { replace: true }): HookUnregister; // prettier-ignore\n\t// Overload: passed in handler options\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookHandler<T>, options: O): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\ton<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\ton<T extends HookName, O extends HookOptions>(\n\t\thook: T,\n\t\thandler: O['replace'] extends true ? HookDefaultHandler<T> : HookHandler<T>,\n\t\toptions: Partial<O> = {}\n\t): HookUnregister {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\tconsole.warn(`Hook '${hook}' not found.`);\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst id = ledger.size + 1;\n\t\tconst registration: HookRegistration<T> = { ...options, id, hook, handler };\n\t\tledger.set(handler, registration);\n\n\t\treturn () => this.off(hook, handler);\n\t}\n\n\t/**\n\t * Register a new hook handler to run before the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { before: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tbefore<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to replace the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { replace: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute instead of the default handler\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\treplace<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookDefaultHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to run once.\n\t * Shortcut for `hooks.on(hook, handler, { once: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tonce<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\t/**\n\t * Unregister a hook handler.\n\t * @param hook Name of the hook the handler is registered for\n\t * @param handler The handler function that was registered.\n\t *                If omitted, all handlers for the hook will be removed.\n\t */\n\t// Overload: unregister a specific handler\n\toff<T extends HookName>(hook: T, handler: HookHandler<T> | HookDefaultHandler<T>): void;\n\t// Overload: unregister all handlers\n\toff<T extends HookName>(hook: T): void;\n\t// Implementation\n\toff<T extends HookName>(hook: T, handler?: HookHandler<T> | HookDefaultHandler<T>): void {\n\t\tconst ledger = this.get(hook);\n\t\tif (ledger && handler) {\n\t\t\tconst deleted = ledger.delete(handler);\n\t\t\tif (!deleted) {\n\t\t\t\tconsole.warn(`Handler for hook '${hook}' not found.`);\n\t\t\t}\n\t\t} else if (ledger) {\n\t\t\tledger.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a hook asynchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order and `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The resolved return value of the executed default handler\n\t */\n\tasync call<T extends HookName>(\n\t\thook: T,\n\t\targs: HookArguments<T>,\n\t\tdefaultHandler?: HookDefaultHandler<T>\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>> {\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tawait this.run(before, args);\n\t\tconst [result] = await this.run(handler, args);\n\t\tawait this.run(after, args);\n\t\tthis.dispatchDomEvent(hook, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Trigger a hook synchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order, but will **not** `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The (possibly unresolved) return value of the executed default handler\n\t */\n\tcallSync<T extends HookName>(\n\t\thook: T,\n\t\targs: HookArguments<T>,\n\t\tdefaultHandler?: HookDefaultHandler<T>\n\t): ReturnType<HookDefaultHandler<T>> {\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tthis.runSync(before, args);\n\t\tconst [result] = this.runSync(handler, args);\n\t\tthis.runSync(after, args);\n\t\tthis.dispatchDomEvent(hook, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, as `Promise`s that will be `await`ed.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], args: HookArguments<T>): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>[]>; // prettier-ignore\n\t// Overload:  running user handler: expect no specific type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T>[], args: HookArguments<T>): Promise<unknown[]>; // prettier-ignore\n\t// Implementation\n\tprotected async run<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\targs: HookArguments<T>\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>> | unknown[]> {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tconst result = await runAsPromise(handler, [this.swup.visit, args, defaultHandler]);\n\t\t\tresults.push(result);\n\t\t\tif (once) {\n\t\t\t\tthis.off(hook, handler);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, without `await`ing any returned `Promise`s.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], args: HookArguments<T> ): ReturnType<HookDefaultHandler<T>>[]; // prettier-ignore\n\t// Overload: running user handler: expect no specific type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T>[], args: HookArguments<T>): unknown[]; // prettier-ignore\n\t// Implementation\n\tprotected runSync<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\targs: HookArguments<T>\n\t): (ReturnType<HookDefaultHandler<T>> | unknown)[] {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tconst result = (handler as HookDefaultHandler<T>)(this.swup.visit, args, defaultHandler); // prettier-ignore\n\t\t\tresults.push(result);\n\t\t\tif (isPromise(result)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Promise returned from handler for synchronous hook '${hook}'.` +\n\t\t\t\t\t\t`Swup will not wait for it to resolve.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (once) {\n\t\t\t\tthis.off(hook, handler);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get all registered handlers for a hook, sorted by priority and registration order.\n\t * @param hook Name of the hook\n\t * @param defaultHandler The optional default handler of this hook\n\t * @returns An object with the handlers sorted into `before` and `after` arrays,\n\t *          as well as a flag indicating if the original handler was replaced\n\t */\n\tprotected getHandlers<T extends HookName>(hook: T, defaultHandler?: HookDefaultHandler<T>) {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\treturn { found: false, before: [], handler: [], after: [], replaced: false };\n\t\t}\n\n\t\tconst registrations = Array.from(ledger.values());\n\n\t\t// Let TypeScript know that replaced handlers are default handlers by filtering to true\n\t\tconst def = (T: HookRegistration<T>): T is HookRegistration<T, HookDefaultHandler<T>> => true; // prettier-ignore\n\t\tconst sort = this.sortRegistrations;\n\n\t\t// Filter into before, after, and replace handlers\n\t\tconst before = registrations.filter(({ before, replace }) => before && !replace).sort(sort);\n\t\tconst replace = registrations.filter(({ replace }) => replace).filter(def).sort(sort); // prettier-ignore\n\t\tconst after = registrations.filter(({ before, replace }) => !before && !replace).sort(sort);\n\t\tconst replaced = replace.length > 0;\n\n\t\t// Define main handler registration\n\t\t// Created as HookRegistration[] array to allow passing it into hooks.run() directly\n\t\tlet handler: HookRegistration<T, HookDefaultHandler<T>>[] = [];\n\t\tif (defaultHandler) {\n\t\t\thandler = [{ id: 0, hook, handler: defaultHandler }];\n\t\t\tif (replaced) {\n\t\t\t\tconst index = replace.length - 1;\n\t\t\t\tconst replacingHandler = replace[index].handler;\n\t\t\t\tconst createDefaultHandler = (index: number): HookDefaultHandler<T> | undefined => {\n\t\t\t\t\tconst next = replace[index - 1];\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\treturn (visit, args) =>\n\t\t\t\t\t\t\tnext.handler(visit, args, createDefaultHandler(index - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn defaultHandler;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst nestedDefaultHandler = createDefaultHandler(index);\n\t\t\t\thandler = [\n\t\t\t\t\t{ id: 0, hook, handler: replacingHandler, defaultHandler: nestedDefaultHandler }\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\treturn { found: true, before, handler, after, replaced };\n\t}\n\n\t/**\n\t * Sort two hook registrations by priority and registration order.\n\t * @param a The registration object to compare\n\t * @param b The other registration object to compare with\n\t * @returns The sort direction\n\t */\n\tprotected sortRegistrations<T extends HookName>(\n\t\ta: HookRegistration<T>,\n\t\tb: HookRegistration<T>\n\t): number {\n\t\tconst priority = (a.priority ?? 0) - (b.priority ?? 0);\n\t\tconst id = a.id - b.id;\n\t\treturn priority || id || 0;\n\t}\n\n\t/**\n\t * Dispatch a custom event on the `document` for a hook. Prefixed with `swup:`\n\t * @param hook Name of the hook.\n\t */\n\tprotected dispatchDomEvent<T extends HookName>(hook: T, args?: HookArguments<T>): void {\n\t\tconst detail = { hook, args, visit: this.swup.visit };\n\t\tdocument.dispatchEvent(new CustomEvent(`swup:${hook}`, { detail }));\n\t}\n}\n","import { escapeCssIdentifier as escape, query } from '../utils.js';\n\n/**\n * Find the anchor element for a given hash.\n *\n * @param hash Hash with or without leading '#'\n * @returns The element, if found, or null.\n *\n * @see https://html.spec.whatwg.org/#find-a-potential-indicated-element\n */\nexport const getAnchorElement = (hash?: string): Element | null => {\n\tif (hash && hash.charAt(0) === '#') {\n\t\thash = hash.substring(1);\n\t}\n\n\tif (!hash) {\n\t\treturn null;\n\t}\n\n\tconst decoded = decodeURIComponent(hash);\n\tlet element =\n\t\tdocument.getElementById(hash) ||\n\t\tdocument.getElementById(decoded) ||\n\t\tquery(`a[name='${escape(hash)}']`) ||\n\t\tquery(`a[name='${escape(decoded)}']`);\n\n\tif (!element && hash === 'top') {\n\t\telement = document.body;\n\t}\n\n\treturn element;\n};\n","import { queryAll, toMs } from '../utils.js';\nimport type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\n\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n\ntype AnimationTypes = typeof TRANSITION | typeof ANIMATION;\ntype AnimationProperties = 'Delay' | 'Duration';\ntype AnimationStyleKeys = `${AnimationTypes}${AnimationProperties}` | 'transitionProperty';\ntype AnimationStyleDeclarations = Pick<CSSStyleDeclaration, AnimationStyleKeys>;\n\nexport type AnimationDirection = 'in' | 'out';\n\n/**\n * Return a Promise that resolves when all CSS animations and transitions\n * are done on the page. Filters by selector or takes elements directly.\n */\nexport async function awaitAnimations(\n\tthis: Swup,\n\t{\n\t\telements,\n\t\tselector\n\t}: {\n\t\tselector: Options['animationSelector'];\n\t\telements?: NodeListOf<HTMLElement> | HTMLElement[];\n\t}\n): Promise<void> {\n\t// Allow usage of swup without animations: { animationSelector: false }\n\tif (selector === false && !elements) {\n\t\treturn;\n\t}\n\n\t// Allow passing in elements\n\tlet animatedElements: HTMLElement[] = [];\n\tif (elements) {\n\t\tanimatedElements = Array.from(elements);\n\t} else if (selector) {\n\t\tanimatedElements = queryAll(selector, document.body);\n\t\t// Warn if no elements match the selector, but keep things going\n\t\tif (!animatedElements.length) {\n\t\t\tconsole.warn(`[swup] No elements found matching animationSelector \\`${selector}\\``);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst awaitedAnimations = animatedElements.map((el) => awaitAnimationsOnElement(el));\n\tconst hasAnimations = awaitedAnimations.filter(Boolean).length > 0;\n\tif (!hasAnimations) {\n\t\tif (selector) {\n\t\t\tconsole.warn(\n\t\t\t\t`[swup] No CSS animation duration defined on elements matching \\`${selector}\\``\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tawait Promise.all(awaitedAnimations);\n}\n\nfunction awaitAnimationsOnElement(element: Element): Promise<void> | false {\n\tconst { type, timeout, propCount } = getTransitionInfo(element);\n\n\t// Resolve immediately if no transition defined\n\tif (!type || !timeout) {\n\t\treturn false;\n\t}\n\n\treturn new Promise((resolve) => {\n\t\tconst endEvent = `${type}end`;\n\t\tconst startTime = performance.now();\n\t\tlet propsTransitioned = 0;\n\n\t\tconst end = () => {\n\t\t\telement.removeEventListener(endEvent, onEnd);\n\t\t\tresolve();\n\t\t};\n\n\t\tconst onEnd: EventListener = (event) => {\n\t\t\t// Skip transitions on child elements\n\t\t\tif (event.target !== element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isTransitionOrAnimationEvent(event)) {\n\t\t\t\tthrow new Error('Not a transition or animation event.');\n\t\t\t}\n\n\t\t\t// Skip transitions that happened before we started listening\n\t\t\tconst elapsedTime = (performance.now() - startTime) / 1000;\n\t\t\tif (elapsedTime < event.elapsedTime) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// End if all properties have transitioned\n\t\t\tif (++propsTransitioned >= propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(() => {\n\t\t\tif (propsTransitioned < propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t}, timeout + 1);\n\n\t\telement.addEventListener(endEvent, onEnd);\n\t});\n}\n\nexport function getTransitionInfo(element: Element, expectedType?: AnimationTypes) {\n\tconst styles = window.getComputedStyle(element) as AnimationStyleDeclarations;\n\n\tconst transitionDelays = getStyleProperties(styles, `${TRANSITION}Delay`);\n\tconst transitionDurations = getStyleProperties(styles, `${TRANSITION}Duration`);\n\tconst transitionTimeout = calculateTimeout(transitionDelays, transitionDurations);\n\tconst animationDelays = getStyleProperties(styles, `${ANIMATION}Delay`);\n\tconst animationDurations = getStyleProperties(styles, `${ANIMATION}Duration`);\n\tconst animationTimeout = calculateTimeout(animationDelays, animationDurations);\n\n\tlet type: AnimationTypes | null = null;\n\tlet timeout = 0;\n\tlet propCount = 0;\n\n\tif (expectedType === TRANSITION) {\n\t\tif (transitionTimeout > 0) {\n\t\t\ttype = TRANSITION;\n\t\t\ttimeout = transitionTimeout;\n\t\t\tpropCount = transitionDurations.length;\n\t\t}\n\t} else if (expectedType === ANIMATION) {\n\t\tif (animationTimeout > 0) {\n\t\t\ttype = ANIMATION;\n\t\t\ttimeout = animationTimeout;\n\t\t\tpropCount = animationDurations.length;\n\t\t}\n\t} else {\n\t\ttimeout = Math.max(transitionTimeout, animationTimeout);\n\t\ttype = timeout > 0 ? (transitionTimeout > animationTimeout ? TRANSITION : ANIMATION) : null;\n\t\tpropCount = type\n\t\t\t? type === TRANSITION\n\t\t\t\t? transitionDurations.length\n\t\t\t\t: animationDurations.length\n\t\t\t: 0;\n\t}\n\n\treturn {\n\t\ttype,\n\t\ttimeout,\n\t\tpropCount\n\t};\n}\n\nfunction isTransitionOrAnimationEvent(event: Event): event is TransitionEvent | AnimationEvent {\n\treturn [`${TRANSITION}end`, `${ANIMATION}end`].includes(event.type);\n}\n\nfunction getStyleProperties(styles: AnimationStyleDeclarations, key: AnimationStyleKeys): string[] {\n\treturn (styles[key] || '').split(', ');\n}\n\nfunction calculateTimeout(delays: string[], durations: string[]): number {\n\twhile (delays.length < durations.length) {\n\t\tdelays = delays.concat(delays);\n\t}\n\n\treturn Math.max(...durations.map((duration, i) => toMs(duration) + toMs(delays[i])));\n}\n","import type Swup from '../Swup.js';\nimport { createHistoryRecord, updateHistoryRecord, getCurrentUrl, Location } from '../helpers.js';\nimport { FetchError, type FetchOptions, type PageData } from './fetchPage.js';\nimport type { VisitInitOptions } from './Visit.js';\n\nexport type HistoryAction = 'push' | 'replace';\nexport type HistoryDirection = 'forwards' | 'backwards';\nexport type NavigationToSelfAction = 'scroll' | 'navigate';\nexport type CacheControl = Partial<{ read: boolean; write: boolean }>;\n\n/** Define how to navigate to a page. */\ntype NavigationOptions = {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate?: boolean;\n\t/** Name of a custom animation to run. */\n\tanimation?: string;\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\thistory?: HistoryAction;\n\t/** Whether this visit should read from or write to the cache. */\n\tcache?: CacheControl;\n};\n\n/**\n * Navigate to a new URL.\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport function navigate(\n\tthis: Swup,\n\turl: string,\n\toptions: NavigationOptions & FetchOptions = {},\n\tinit: Omit<VisitInitOptions, 'to'> = {}\n) {\n\tif (typeof url !== 'string') {\n\t\tthrow new Error(`swup.navigate() requires a URL parameter`);\n\t}\n\n\t// Check if the visit should be ignored\n\tif (this.shouldIgnoreVisit(url, { el: init.el, event: init.event })) {\n\t\twindow.location.href = url;\n\t\treturn;\n\t}\n\n\tconst { url: to, hash } = Location.fromUrl(url);\n\tthis.visit = this.createVisit({ ...init, to, hash });\n\tthis.performNavigation(options);\n}\n\n/**\n * Start a visit to a new URL.\n *\n * Internal method that assumes the visit context has already been created.\n *\n * As a user, you should call `swup.navigate(url)` instead.\n *\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport async function performNavigation(\n\tthis: Swup,\n\toptions: NavigationOptions & FetchOptions = {}\n): Promise<void> {\n\tthis.navigating = true;\n\t// Save this localy to a) allow ignoring the visit if a new one was started in the meantime\n\t// and b) avoid unintended modifications to any newer visits\n\tconst visit = this.visit;\n\n\tconst { el } = visit.trigger;\n\toptions.referrer = options.referrer || this.currentPageUrl;\n\n\tif (options.animate === false) {\n\t\tvisit.animation.animate = false;\n\t}\n\n\t// Clean up old animation classes\n\tif (!visit.animation.animate) {\n\t\tthis.classes.clear();\n\t}\n\n\t// Get history action from option or attribute on trigger element\n\tconst history = options.history || el?.getAttribute('data-swup-history') || undefined;\n\tif (history && ['push', 'replace'].includes(history)) {\n\t\tvisit.history.action = history as HistoryAction;\n\t}\n\n\t// Get custom animation name from option or attribute on trigger element\n\tconst animation = options.animation || el?.getAttribute('data-swup-animation') || undefined;\n\tif (animation) {\n\t\tvisit.animation.name = animation;\n\t}\n\n\t// Sanitize cache option\n\tif (typeof options.cache === 'object') {\n\t\tvisit.cache.read = options.cache.read ?? visit.cache.read;\n\t\tvisit.cache.write = options.cache.write ?? visit.cache.write;\n\t} else if (options.cache !== undefined) {\n\t\tvisit.cache = { read: !!options.cache, write: !!options.cache };\n\t}\n\t// Delete this so that window.fetch doesn't mis-interpret it\n\tdelete options.cache;\n\n\ttry {\n\t\tawait this.hooks.call('visit:start', undefined);\n\n\t\t// Begin loading page\n\t\tconst pagePromise = this.hooks.call('page:load', { options }, async (visit, args) => {\n\t\t\t// Read from cache\n\t\t\tlet cachedPage: PageData | undefined;\n\t\t\tif (visit.cache.read) {\n\t\t\t\tcachedPage = this.cache.get(visit.to.url);\n\t\t\t}\n\n\t\t\targs.page = cachedPage || (await this.fetchPage(visit.to.url, args.options));\n\t\t\targs.cache = !!cachedPage;\n\n\t\t\treturn args.page;\n\t\t});\n\n\t\t// Create/update history record if this is not a popstate call or leads to the same URL\n\t\tif (!visit.history.popstate) {\n\t\t\t// Add the hash directly from the trigger element\n\t\t\tconst newUrl = visit.to.url + visit.to.hash;\n\t\t\tif (visit.history.action === 'replace' || visit.to.url === this.currentPageUrl) {\n\t\t\t\tupdateHistoryRecord(newUrl);\n\t\t\t} else {\n\t\t\t\tthis.currentHistoryIndex++;\n\t\t\t\tcreateHistoryRecord(newUrl, { index: this.currentHistoryIndex });\n\t\t\t}\n\t\t}\n\n\t\tthis.currentPageUrl = getCurrentUrl();\n\n\t\t// Wait for page before starting to animate out?\n\t\tif (visit.animation.wait) {\n\t\t\tconst { html } = await pagePromise;\n\t\t\tvisit.to.html = html;\n\t\t}\n\n\t\t// perform the actual transition: animate and replace content\n\t\tawait this.hooks.call('visit:transition', undefined, async (visit) => {\n\t\t\t// Start leave animation\n\t\t\tconst animationPromise = this.animatePageOut();\n\n\t\t\t// Wait for page to load and leave animation to finish\n\t\t\tconst [page] = await Promise.all([pagePromise, animationPromise]);\n\n\t\t\t// Abort if another visit was started in the meantime\n\t\t\tif (visit.id !== this.visit.id) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Render page: replace content and scroll to top/fragment\n\t\t\tawait this.renderPage(page);\n\n\t\t\t// Wait for enter animation\n\t\t\tawait this.animatePageIn();\n\n\t\t\treturn true;\n\t\t});\n\n\t\t// Finalize visit\n\t\tawait this.hooks.call('visit:end', undefined, () => this.classes.clear());\n\n\t\t// Reset visit info after finish?\n\t\t// if (visit.to && this.isSameResolvedUrl(visit.to.url, requestedUrl)) {\n\t\t// \tthis.visit = this.createVisit({ to: undefined });\n\t\t// }\n\t\tthis.navigating = false;\n\t} catch (error) {\n\t\t// Return early if error is undefined or signals an aborted request\n\t\tif (!error || (error as FetchError)?.aborted) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Log to console as we swallow almost all hook errors\n\t\tconsole.error(error);\n\n\t\t// Rewrite `skipPopStateHandling` to redirect manually when `history.go` is processed\n\t\tthis.options.skipPopStateHandling = () => {\n\t\t\twindow.location.href = visit.to.url + visit.to.hash;\n\t\t\treturn true;\n\t\t};\n\n\t\t// Go back to the actual page we're still at\n\t\twindow.history.go(-1);\n\t}\n}\n","import type Swup from '../Swup.js';\nimport { classify } from '../helpers.js';\n\n/**\n * Perform the out/leave animation of the current page.\n * @returns Promise<void>\n */\nexport const animatePageOut = async function (this: Swup) {\n\tif (!this.visit.animation.animate) {\n\t\tawait this.hooks.call('animation:skip', undefined);\n\t\treturn;\n\t}\n\n\tawait this.hooks.call('animation:out:start', undefined, (visit) => {\n\t\tthis.classes.add('is-changing', 'is-leaving', 'is-animating');\n\t\tif (visit.history.popstate) {\n\t\t\tthis.classes.add('is-popstate');\n\t\t}\n\t\tif (visit.animation.name) {\n\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t}\n\t});\n\n\tawait this.hooks.call('animation:out:await', { skip: false }, async (visit, { skip }) => {\n\t\tif (skip) return;\n\t\tawait this.awaitAnimations({ selector: visit.animation.selector });\n\t});\n\n\tawait this.hooks.call('animation:out:end', undefined);\n};\n","import type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\nimport { query, queryAll } from '../utils.js';\nimport type { PageData } from './fetchPage.js';\n\n/**\n * Perform the replacement of content after loading a page.\n *\n * It takes an object with the page data as returned from `fetchPage` and a list\n * of container selectors to replace.\n *\n * @returns Whether all containers were replaced.\n */\nexport const replaceContent = function (\n\tthis: Swup,\n\t{ html }: PageData,\n\t{ containers }: { containers: Options['containers'] } = this.options\n): boolean {\n\tconst incomingDocument = new DOMParser().parseFromString(html, 'text/html');\n\n\t// Update browser title\n\tconst title = incomingDocument.querySelector('title')?.innerText || '';\n\tdocument.title = title;\n\n\t// Save persisted elements\n\tconst persistedElements = queryAll('[data-swup-persist]:not([data-swup-persist=\"\"])');\n\n\t// Update content containers\n\tconst replaced = containers\n\t\t.map((selector) => {\n\t\t\tconst currentEl = document.querySelector(selector);\n\t\t\tconst incomingEl = incomingDocument.querySelector(selector);\n\t\t\tif (currentEl && incomingEl) {\n\t\t\t\tcurrentEl.replaceWith(incomingEl);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!currentEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in current document: ${selector}`);\n\t\t\t}\n\t\t\tif (!incomingEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in incoming document: ${selector}`);\n\t\t\t}\n\t\t\treturn false;\n\t\t})\n\t\t.filter(Boolean);\n\n\t// Restore persisted elements\n\tpersistedElements.forEach((existing) => {\n\t\tconst key = existing.getAttribute('data-swup-persist');\n\t\tconst replacement = query(`[data-swup-persist=\"${key}\"]`);\n\t\tif (replacement && replacement !== existing) {\n\t\t\treplacement.replaceWith(existing);\n\t\t}\n\t});\n\n\treturn replaced.length === containers.length;\n};\n","import type Swup from '../Swup.js';\n\n/**\n * Update the scroll position after page render.\n * @returns Promise<boolean>\n */\nexport const scrollToContent = function (this: Swup): boolean {\n\tconst options: ScrollIntoViewOptions = { behavior: 'auto' };\n\tconst { target, reset } = this.visit.scroll;\n\tconst scrollTarget = target ?? this.visit.to.hash;\n\n\tlet scrolled = false;\n\n\tif (scrollTarget) {\n\t\tscrolled = this.hooks.callSync(\n\t\t\t'scroll:anchor',\n\t\t\t{ hash: scrollTarget, options },\n\t\t\t(visit, { hash, options }) => {\n\t\t\t\tconst anchor = this.getAnchorElement(hash);\n\t\t\t\tif (anchor) {\n\t\t\t\t\tanchor.scrollIntoView(options);\n\t\t\t\t}\n\t\t\t\treturn !!anchor;\n\t\t\t}\n\t\t);\n\t}\n\n\tif (reset && !scrolled) {\n\t\tscrolled = this.hooks.callSync('scroll:top', { options }, (visit, { options }) => {\n\t\t\twindow.scrollTo({ top: 0, left: 0, ...options });\n\t\t\treturn true;\n\t\t});\n\t}\n\n\treturn scrolled;\n};\n","import type Swup from '../Swup.js';\nimport { nextTick } from '../utils.js';\n\n/**\n * Perform the in/enter animation of the next page.\n * @returns Promise<void>\n */\nexport const animatePageIn = async function (this: Swup) {\n\tif (!this.visit.animation.animate) {\n\t\treturn;\n\t}\n\n\tconst animation = this.hooks.call(\n\t\t'animation:in:await',\n\t\t{ skip: false },\n\t\tasync (visit, { skip }) => {\n\t\t\tif (skip) return;\n\t\t\tawait this.awaitAnimations({ selector: visit.animation.selector });\n\t\t}\n\t);\n\n\tawait nextTick();\n\n\tawait this.hooks.call('animation:in:start', undefined, () => {\n\t\tthis.classes.remove('is-animating');\n\t});\n\n\tawait animation;\n\n\tawait this.hooks.call('animation:in:end', undefined);\n};\n","import { updateHistoryRecord, getCurrentUrl, classify } from '../helpers.js';\nimport type Swup from '../Swup.js';\nimport type { PageData } from './fetchPage.js';\n\n/**\n * Render the next page: replace the content and update scroll position.\n */\nexport const renderPage = async function (this: Swup, page: PageData): Promise<void> {\n\tconst { url, html } = page;\n\n\tthis.classes.remove('is-leaving');\n\n\t// update state if the url was redirected\n\tif (!this.isSameResolvedUrl(getCurrentUrl(), url)) {\n\t\tupdateHistoryRecord(url);\n\t\tthis.currentPageUrl = getCurrentUrl();\n\t\tthis.visit.to.url = this.currentPageUrl;\n\t}\n\n\t// only add for animated page loads\n\tif (this.visit.animation.animate) {\n\t\tthis.classes.add('is-rendering');\n\t}\n\n\t// save html into visit context for easier retrieval\n\tthis.visit.to.html = html;\n\n\t// replace content: allow handlers and plugins to overwrite paga data and containers\n\tawait this.hooks.call('content:replace', { page }, (visit, { page }) => {\n\t\tconst success = this.replaceContent(page, { containers: visit.containers });\n\t\tif (!success) {\n\t\t\tthrow new Error('[swup] Container mismatch, aborting');\n\t\t}\n\t\tif (visit.animation.animate) {\n\t\t\t// Make sure to add these classes to new containers as well\n\t\t\tthis.classes.add('is-animating', 'is-changing', 'is-rendering');\n\t\t\tif (visit.animation.name) {\n\t\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// scroll into view: either anchor or top of page\n\t// @ts-ignore: not returning a promise is intentional to allow users to pause in handler\n\tawait this.hooks.call('content:scroll', undefined, () => {\n\t\treturn this.scrollToContent();\n\t});\n\n\tawait this.hooks.call('page:view', { url: this.currentPageUrl, title: document.title });\n};\n","import type Swup from '../Swup.js';\n\nexport type Plugin = {\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true;\n\t/** Name of this plugin */\n\tname: string;\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\t/** The swup instance that mounted this plugin */\n\tswup?: Swup;\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]>;\n\t/** Run on mount */\n\tmount: () => void;\n\t/** Run on unmount */\n\tunmount: () => void;\n\t_beforeMount?: () => void;\n\t_afterUnmount?: () => void;\n\t_checkRequirements?: () => boolean;\n};\n\nconst isSwupPlugin = (maybeInvalidPlugin: unknown): maybeInvalidPlugin is Plugin => {\n\t// @ts-ignore: this might be anything, object or no\n\treturn Boolean(maybeInvalidPlugin?.isSwupPlugin);\n};\n\n/** Install a plugin. */\nexport const use = function (this: Swup, plugin: unknown) {\n\tif (!isSwupPlugin(plugin)) {\n\t\tconsole.error('Not a swup plugin instance', plugin);\n\t\treturn;\n\t}\n\n\tplugin.swup = this;\n\tif (plugin._checkRequirements) {\n\t\tif (!plugin._checkRequirements()) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (plugin._beforeMount) {\n\t\tplugin._beforeMount();\n\t}\n\tplugin.mount();\n\n\tthis.plugins.push(plugin);\n\n\treturn this.plugins;\n};\n\n/** Uninstall a plugin. */\nexport function unuse(this: Swup, pluginOrName: Plugin | string) {\n\tconst plugin = this.findPlugin(pluginOrName);\n\tif (!plugin) {\n\t\tconsole.error('No such plugin', plugin);\n\t\treturn;\n\t}\n\n\tplugin.unmount();\n\tif (plugin._afterUnmount) {\n\t\tplugin._afterUnmount();\n\t}\n\n\tthis.plugins = this.plugins.filter((p) => p !== plugin);\n\n\treturn this.plugins;\n}\n\n/** Find a plugin by name or reference. */\nexport function findPlugin(this: Swup, pluginOrName: Plugin | string) {\n\treturn this.plugins.find(\n\t\t(plugin) =>\n\t\t\tplugin === pluginOrName ||\n\t\t\tplugin.name === pluginOrName ||\n\t\t\tplugin.name === `Swup${String(pluginOrName)}`\n\t);\n}\n","import type Swup from '../Swup.js';\n\n/**\n * Utility function to validate and run the global option 'resolveUrl'\n * @param {string} url\n * @returns {string} the resolved url\n */\nexport function resolveUrl(this: Swup, url: string): string {\n\tif (typeof this.options.resolveUrl !== 'function') {\n\t\tconsole.warn(`[swup] options.resolveUrl expects a callback function.`);\n\t\treturn url;\n\t}\n\tconst result = this.options.resolveUrl(url);\n\tif (!result || typeof result !== 'string') {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a url`);\n\t\treturn url;\n\t}\n\tif (result.startsWith('//') || result.startsWith('http')) {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a relative url`);\n\t\treturn url;\n\t}\n\treturn result;\n}\n\n/**\n * Compares the resolved version of two paths and returns true if they are the same\n * @param {string} url1\n * @param {string} url2\n * @returns {boolean}\n */\nexport function isSameResolvedUrl(this: Swup, url1: string, url2: string): boolean {\n\treturn this.resolveUrl(url1) === this.resolveUrl(url2);\n}\n","import { type DelegateEvent } from 'delegate-it';\n\nimport version from './config/version.js';\n\nimport { delegateEvent, getCurrentUrl, Location, updateHistoryRecord } from './helpers.js';\nimport { type DelegateEventUnsubscribe } from './helpers/delegateEvent.js';\n\nimport { Cache } from './modules/Cache.js';\nimport { Classes } from './modules/Classes.js';\nimport { type Visit, createVisit } from './modules/Visit.js';\nimport { Hooks } from './modules/Hooks.js';\nimport { getAnchorElement } from './modules/getAnchorElement.js';\nimport { awaitAnimations } from './modules/awaitAnimations.js';\nimport { navigate, performNavigation, type NavigationToSelfAction } from './modules/navigate.js';\nimport { fetchPage } from './modules/fetchPage.js';\nimport { animatePageOut } from './modules/animatePageOut.js';\nimport { replaceContent } from './modules/replaceContent.js';\nimport { scrollToContent } from './modules/scrollToContent.js';\nimport { animatePageIn } from './modules/animatePageIn.js';\nimport { renderPage } from './modules/renderPage.js';\nimport { use, unuse, findPlugin, type Plugin } from './modules/plugins.js';\nimport { isSameResolvedUrl, resolveUrl } from './modules/resolveUrl.js';\nimport { nextTick } from './utils.js';\nimport { type HistoryState } from './helpers/createHistoryRecord.js';\n\n/** Options for customizing swup's behavior. */\nexport type Options = {\n\t/** Whether history visits are animated. Default: `false` */\n\tanimateHistoryBrowsing: boolean;\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tanimationSelector: string | false;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tanimationScope: 'html' | 'containers';\n\t/** Enable in-memory page cache. Default: `true` */\n\tcache: boolean;\n\t/** Content containers to be replaced on page visits. Default: `['#swup']` */\n\tcontainers: string[];\n\t/** Callback for ignoring visits. Receives the element and event that triggered the visit. */\n\tignoreVisit: (url: string, { el, event }: { el?: Element; event?: Event }) => boolean;\n\t/** Selector for links that trigger visits. Default: `'a[href]'` */\n\tlinkSelector: string;\n\t/** How swup handles links to the same page. Default: `scroll` */\n\tlinkToSelf: NavigationToSelfAction;\n\t/** Plugins to register on startup. */\n\tplugins: Plugin[];\n\t/** Custom headers sent along with fetch requests. */\n\trequestHeaders: Record<string, string>;\n\t/** Rewrite URLs before loading them. */\n\tresolveUrl: (url: string) => string;\n\t/** Callback for telling swup to ignore certain popstate events.  */\n\tskipPopStateHandling: (event: PopStateEvent) => boolean;\n\t/** Request timeout in milliseconds. */\n\ttimeout: number;\n};\n\nconst defaults: Options = {\n\tanimateHistoryBrowsing: false,\n\tanimationSelector: '[class*=\"transition-\"]',\n\tanimationScope: 'html',\n\tcache: true,\n\tcontainers: ['#swup'],\n\tignoreVisit: (url, { el } = {}) => !!el?.closest('[data-no-swup]'),\n\tlinkSelector: 'a[href]',\n\tlinkToSelf: 'scroll',\n\tplugins: [],\n\tresolveUrl: (url) => url,\n\trequestHeaders: {\n\t\t'X-Requested-With': 'swup',\n\t\t'Accept': 'text/html, application/xhtml+xml'\n\t},\n\tskipPopStateHandling: (event) => (event.state as HistoryState)?.source !== 'swup',\n\ttimeout: 0\n};\n\n/** Swup page transition library. */\nexport default class Swup {\n\t/** Library version */\n\treadonly version: string = version;\n\t/** Options passed into the instance */\n\toptions: Options;\n\t/** Default options before merging user options */\n\treadonly defaults: Options = defaults;\n\t/** Registered plugin instances */\n\tplugins: Plugin[] = [];\n\t/** Data about the current visit */\n\tvisit: Visit;\n\t/** Cache instance */\n\treadonly cache: Cache;\n\t/** Hook registry */\n\treadonly hooks: Hooks;\n\t/** Animation class manager */\n\treadonly classes: Classes;\n\t/** URL of the currently visible page */\n\tcurrentPageUrl: string = getCurrentUrl();\n\t/** Index of the current history entry */\n\tprotected currentHistoryIndex: number;\n\t/** Delegated event subscription handle */\n\tprotected clickDelegate?: DelegateEventUnsubscribe;\n\t/** Navigation status */\n\tprotected navigating: boolean = false;\n\n\t/** Install a plugin */\n\tuse = use;\n\t/** Uninstall a plugin */\n\tunuse = unuse;\n\t/** Find a plugin by name or instance */\n\tfindPlugin = findPlugin;\n\n\t/** Log a message. Has no effect unless debug plugin is installed */\n\tlog: (message: string, context?: unknown) => void = () => {};\n\n\t/** Navigate to a new URL */\n\tnavigate = navigate;\n\t/** Actually perform a navigation */\n\tprotected performNavigation = performNavigation;\n\t/** Create a new context for this visit */\n\tprotected createVisit = createVisit;\n\t/** Register a delegated event listener */\n\tdelegateEvent = delegateEvent;\n\t/** Fetch a page from the server */\n\tfetchPage = fetchPage;\n\t/** Resolve when animations on the page finish */\n\tawaitAnimations = awaitAnimations;\n\tprotected renderPage = renderPage;\n\t/** Replace the content after page load */\n\treplaceContent = replaceContent;\n\tprotected animatePageIn = animatePageIn;\n\tprotected animatePageOut = animatePageOut;\n\tprotected scrollToContent = scrollToContent;\n\t/** Find the anchor element for a given hash */\n\tgetAnchorElement = getAnchorElement;\n\n\t/** Get the current page URL */\n\tgetCurrentUrl = getCurrentUrl;\n\t/** Resolve a URL to its final location */\n\tresolveUrl = resolveUrl;\n\t/** Check if two URLs resolve to the same location */\n\tprotected isSameResolvedUrl = isSameResolvedUrl;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\t// Merge defaults and options\n\t\tthis.options = { ...this.defaults, ...options };\n\n\t\tthis.handleLinkClick = this.handleLinkClick.bind(this);\n\t\tthis.handlePopState = this.handlePopState.bind(this);\n\n\t\tthis.cache = new Cache(this);\n\t\tthis.classes = new Classes(this);\n\t\tthis.hooks = new Hooks(this);\n\t\tthis.visit = this.createVisit({ to: '' });\n\n\t\tthis.currentHistoryIndex = (history.state as HistoryState)?.index ?? 1;\n\n\t\tif (!this.checkRequirements()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.enable();\n\t}\n\n\tprotected checkRequirements() {\n\t\tif (typeof Promise === 'undefined') {\n\t\t\tconsole.warn('Promise is not supported');\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Enable this instance, adding listeners and classnames. */\n\tasync enable() {\n\t\t// Add event listener\n\t\tconst { linkSelector } = this.options;\n\t\tthis.clickDelegate = this.delegateEvent(linkSelector, 'click', this.handleLinkClick);\n\n\t\twindow.addEventListener('popstate', this.handlePopState);\n\n\t\t// Set scroll restoration to manual if animating history visits\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// Initial save to cache\n\t\tif (this.options.cache) {\n\t\t\t// Disabled to avoid caching modified dom state: logic moved to preload plugin\n\t\t\t// https://github.com/swup/swup/issues/475\n\t\t}\n\n\t\t// Mount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.use(plugin));\n\n\t\t// Create initial history record\n\t\tif ((history.state as HistoryState)?.source !== 'swup') {\n\t\t\tupdateHistoryRecord(null, { index: this.currentHistoryIndex });\n\t\t}\n\n\t\t// Give consumers a chance to hook into enable\n\t\tawait nextTick();\n\n\t\t// Trigger enable hook\n\t\tawait this.hooks.call('enable', undefined, () => {\n\t\t\t// Add swup-enabled class to html tag\n\t\t\tdocument.documentElement.classList.add('swup-enabled');\n\t\t});\n\t}\n\n\t/** Disable this instance, removing listeners and classnames. */\n\tasync destroy() {\n\t\t// remove delegated listener\n\t\tthis.clickDelegate!.destroy();\n\n\t\t// remove popstate listener\n\t\twindow.removeEventListener('popstate', this.handlePopState);\n\n\t\t// empty cache\n\t\tthis.cache.clear();\n\n\t\t// unmount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.unuse(plugin));\n\n\t\t// trigger disable hook\n\t\tawait this.hooks.call('disable', undefined, () => {\n\t\t\t// remove swup-enabled class from html tag\n\t\t\tdocument.documentElement.classList.remove('swup-enabled');\n\t\t});\n\n\t\t// remove handlers\n\t\tthis.hooks.clear();\n\t}\n\n\t/** Determine if a visit should be ignored by swup, based on URL or trigger element. */\n\tshouldIgnoreVisit(href: string, { el, event }: { el?: Element; event?: Event } = {}) {\n\t\tconst { origin, url, hash } = Location.fromUrl(href);\n\n\t\t// Ignore if the new origin doesn't match the current one\n\t\tif (origin !== window.location.origin) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the link/form would open a new window (or none at all)\n\t\tif (el && this.triggerWillOpenNewWindow(el)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the visit should be ignored as per user options\n\t\tif (this.options.ignoreVisit(url + hash, { el, event })) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Finally, allow the visit\n\t\treturn false;\n\t}\n\n\tprotected handleLinkClick(event: DelegateEvent<MouseEvent>) {\n\t\tconst el = event.delegateTarget as HTMLAnchorElement;\n\t\tconst { href, url, hash } = Location.fromElement(el);\n\n\t\t// Exit early if the link should be ignored\n\t\tif (this.shouldIgnoreVisit(href, { el, event })) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ignore if swup is currently navigating towards the link's URL\n\t\tif (this.navigating && url === this.visit.to.url) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.visit = this.createVisit({ to: url, hash, el, event });\n\n\t\t// Exit early if control key pressed\n\t\tif (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {\n\t\t\tthis.hooks.call('link:newtab', { href });\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if other than left mouse button\n\t\tif (event.button !== 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hooks.callSync('link:click', { el, event }, () => {\n\t\t\tconst from = this.visit.from.url ?? '';\n\n\t\t\tevent.preventDefault();\n\n\t\t\t// Handle links to the same page\n\t\t\tif (!url || url === from) {\n\t\t\t\tif (hash) {\n\t\t\t\t\t// With hash: scroll to anchor\n\t\t\t\t\tthis.hooks.callSync('link:anchor', { hash }, () => {\n\t\t\t\t\t\tupdateHistoryRecord(url + hash);\n\t\t\t\t\t\tthis.scrollToContent();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Without hash: scroll to top or load/reload page\n\t\t\t\t\tthis.hooks.callSync('link:self', undefined, () => {\n\t\t\t\t\t\tswitch (this.options.linkToSelf) {\n\t\t\t\t\t\t\tcase 'navigate':\n\t\t\t\t\t\t\t\treturn this.performNavigation();\n\t\t\t\t\t\t\tcase 'scroll':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tupdateHistoryRecord(url);\n\t\t\t\t\t\t\t\treturn this.scrollToContent();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Exit early if the resolved path hasn't changed\n\t\t\tif (this.isSameResolvedUrl(url, from)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Finally, proceed with loading the page\n\t\t\tthis.performNavigation();\n\t\t});\n\t}\n\n\tprotected handlePopState(event: PopStateEvent) {\n\t\tconst href: string = (event.state as HistoryState)?.url ?? location.href;\n\n\t\t// Exit early if this event should be ignored\n\t\tif (this.options.skipPopStateHandling(event)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if the resolved path hasn't changed\n\t\tif (this.isSameResolvedUrl(getCurrentUrl(), this.currentPageUrl)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { url, hash } = Location.fromUrl(href);\n\n\t\tthis.visit = this.createVisit({ to: url, hash, event });\n\n\t\t// Mark as history visit\n\t\tthis.visit.history.popstate = true;\n\n\t\t// Determine direction of history visit\n\t\tconst index = (event.state as HistoryState)?.index ?? 0;\n\t\tif (index && index !== this.currentHistoryIndex) {\n\t\t\tconst direction = index - this.currentHistoryIndex > 0 ? 'forwards' : 'backwards';\n\t\t\tthis.visit.history.direction = direction;\n\t\t\tthis.currentHistoryIndex = index;\n\t\t}\n\n\t\t// Disable animation & scrolling for history visits\n\t\tthis.visit.animation.animate = false;\n\t\tthis.visit.scroll.reset = false;\n\t\tthis.visit.scroll.target = false;\n\n\t\t// Animated history visit: re-enable animation & scroll reset\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\tthis.visit.animation.animate = true;\n\t\t\tthis.visit.scroll.reset = true;\n\t\t}\n\n\t\t// Does this even do anything?\n\t\t// if (!hash) {\n\t\t// \tevent.preventDefault();\n\t\t// }\n\n\t\tthis.hooks.callSync('history:popstate', { event }, () => {\n\t\t\tthis.performNavigation();\n\t\t});\n\t}\n\n\t/** Determine whether an element will open a new tab when clicking/activating. */\n\tprotected triggerWillOpenNewWindow(triggerEl: Element) {\n\t\tif (triggerEl.matches('[download], [target=\"_blank\"]')) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n","import { match } from 'path-to-regexp';\n\nimport type {\n\tPath,\n\tParseOptions,\n\tTokensToRegexpOptions,\n\tRegexpToFunctionOptions,\n\tMatchFunction\n} from 'path-to-regexp';\n\nexport { type Path };\n\n/** Create a match function from a path pattern that checks if a URLs matches it. */\nexport const matchPath = <P extends object = object>(\n\tpath: Path,\n\toptions?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n): MatchFunction<P> => {\n\ttry {\n\t\treturn match<P>(path, options);\n\t} catch (error) {\n\t\tthrow new Error(`[swup] Error parsing path \"${String(path)}\":\\n${String(error)}`);\n\t}\n};\n"],"names":["classify","text","fallback","String","toLowerCase","replace","getCurrentUrl","_temp","hash","location","pathname","search","createHistoryRecord","url","customData","data","random","Math","source","history","pushState","updateHistoryRecord","state","replaceState","delegateEvent","selector","type","callback","options","controller","AbortController","signal","delegate","destroy","abort","Location","URL","constructor","base","document","baseURI","super","toString","this","fromElement","el","href","getAttribute","fromUrl","fetchPage","_this","_temp2","_result","status","responseUrl","response","Promise","resolve","then","html","hooks","call","FetchError","finalUrl","page","visit","cache","write","method","set","headers","requestHeaders","timeout","timedOut","timeoutId","setTimeout","_ref","fetch","_this$hooks$call","clearTimeout","_catch","error","name","aborted","e","reject","Error","message","details","Cache","swup","pages","Map","size","all","copy","forEach","key","has","get","result","callSync","update","payload","delete","clear","undefined","prune","predicate","urlToResolve","resolveUrl","query","context","querySelector","queryAll","Array","from","querySelectorAll","nextTick","requestAnimationFrame","isPromise","obj","runAsPromise","func","args","escapeCssIdentifier","ident","window","CSS","escape","toMs","s","Number","slice","Classes","swupClasses","selectors","scope","animation","containers","isArray","join","targets","trim","add","target","classList","arguments","remove","className","split","filter","c","isSwupClass","some","startsWith","createVisit","to","currentPageUrl","event","id","animate","wait","animationScope","animationSelector","trigger","read","action","popstate","direction","scroll","reset","_iteratorSymbol","Symbol","iterator","pact","value","_Pact","o","_settle","bind","v","observer","onFulfilled","onRejected","_isSettledPact","thenable","Hooks","registry","init","hook","create","exists","ledger","console","on","handler","warn","registration","off","before","once","defaultHandler","after","getHandlers","run","dispatchDomEvent","runSync","registrations","_this2","results","body","check","step","_cycle","next","done","return","_fixup","TypeError","values","i","push","array","length","_forOf","_ref2","found","replaced","sort","sortRegistrations","_ref3","_ref4","T","_ref5","index","createDefaultHandler","a","b","priority","dispatchEvent","CustomEvent","detail","getAnchorElement","charAt","substring","decoded","decodeURIComponent","element","getElementById","awaitAnimations","elements","animatedElements","awaitedAnimations","map","propCount","expectedType","styles","getComputedStyle","transitionDelays","getStyleProperties","TRANSITION","transitionDurations","transitionTimeout","calculateTimeout","animationDelays","ANIMATION","animationDurations","animationTimeout","max","getTransitionInfo","endEvent","startTime","performance","now","propsTransitioned","end","removeEventListener","onEnd","includes","isTransitionOrAnimationEvent","elapsedTime","addEventListener","awaitAnimationsOnElement","Boolean","delays","durations","concat","duration","performNavigation","navigating","referrer","classes","animationPromise","animatePageOut","pagePromise","renderPage","animatePageIn","_temp3","_this$fetchPage","cachedPage","newUrl","currentHistoryIndex","skipPopStateHandling","go","navigate","shouldIgnoreVisit","_exit","skip","replaceContent","incomingDocument","DOMParser","parseFromString","title","innerText","persistedElements","currentEl","incomingEl","replaceWith","existing","replacement","scrollToContent","behavior","scrollTarget","scrolled","anchor","scrollIntoView","scrollTo","top","left","isSameResolvedUrl","use","plugin","maybeInvalidPlugin","isSwupPlugin","_checkRequirements","_beforeMount","mount","plugins","unuse","pluginOrName","findPlugin","unmount","_afterUnmount","p","find","url1","url2","defaults","animateHistoryBrowsing","ignoreVisit","closest","linkSelector","linkToSelf","Accept","version","clickDelegate","log","handleLinkClick","handlePopState","checkRequirements","enable","scrollRestoration","documentElement","origin","triggerWillOpenNewWindow","delegateTarget","preventDefault","metaKey","ctrlKey","shiftKey","altKey","button","triggerEl","matches","offsetHeight","matchPath","path","match"],"mappings":"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"}